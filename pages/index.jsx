// Here we want to set some title, and we definitely also wanna add a description.
// To do that, we can import a special component offered by NEXTjs called
// the Head component
// This is a component which allows us to add Head elements to the Head section
// of our page.
// We simply add it to our returned JSX code!
// Inside of there, we can now insert our Head elements. So all the HTML
// elements which we can add in the Head section, we can add it inside the
// Head component like for example the <title></title> tag and so on.
import Head from 'next/head';
import { MongoClient } from 'mongodb';

import MeetupList from '@/components/meetups/MeetupList';
import { Fragment } from 'react';
// import { useEffect, useState } from 'react';

// getStaticProps, getStaticPaths and getServerSideProps: This functions allow
// us to fetch data for pre-rendering those pages so that we pre-render the pages
// with the data instead of without the data they might need.

const DUMMY_MEETUPS = [
  {
    id: 'm1',
    title: 'A First Meetup',
    image:
      'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1200px-Stadtbild_M%C3%BCnchen.jpg?20130611211153',
    address: 'Some address 1, 1234 Some City',
    description: 'This is a first meetup!',
  },
  {
    id: 'm2',
    title: 'A Second Meetup',
    image:
      'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1200px-Stadtbild_M%C3%BCnchen.jpg?20130611211153',
    address: 'Some address 2, 1234 Some City',
    description: 'This is a second meetup!',
  },
];

function HomePage(props) {
  /*
  const [loadedMeetups, setLoadedMeetups] = useState([]);

  // useEffect works 'afer the component function executes'
  // i.e we have two component render cycle.
  // The first time this component renders, the loadedMeetups state will be
  // this initial state of an empty array.
  // What's important here is:
  // Because if we would fetch this from a backend, our users might see a loading
  // spinner briefly which could or could not be the user experience we wanna
  // offer. But in addition, even here where we don't really send a request and
  // where the response "arrives basically instantly" even in this case.
  // Because of this two render cycles, we have a problem with Search Engine
  // Optimization.
  // If we view the page source, we will notice that the actual meetup data is
  // missing.
  // So the items which we see on the screen, all meetups and details, they are
  // missing in the HTML content in the HTML page we fetched from the server.
  // And they are missing because they are only rendered in a second component
  // execution cycle.
  // But the pre-rendered HTML page generated by NEXTjs automatically does not
  // wait for this second cycle.
  // It always takes the result of the first render cycle and returns that as
  // the pre-rendered HTML code.
  // And there, this data (all meetups pics and details), is missing.
  // Here, with the dummy data, it is redundant to do it like this i.e inside useEffect
  // But we are basically just simulating that we do fetch this data from a server
  // And then we'll face the problem that NEXTjs does not wait for that data
  // to be fetched to then return the fully pre-rendered page.
  // But it returns the result of the first component rendered cycle.
  // And that might be a pretty empty page when we view src code!!!
  // Thankfully, NEXTjs has solution for this problem.
  // It has more core features built into NEXtjs that helps us with precisely
  // this problem, that we wanna pre-render a page with data, but with data
  // for which we have to wait. And we need to tell NEXTjs, once we're done waiting!

  // NEXTjs has this built-in page pre-rendering but this builtin process has
  // a flaw. The page that is pre-rendered has basically the snapshot after
  // the first component render cycle as its content. And that might be missing
  // crucial data. So if we visit some route i.e /some-route, if some request
  // is sent to some-route to this page then, there we return that pre-rendered
  // page but we might be missing data here.
  // So whilst this is theoretically good for SEO, it might not always be.
  // But after this HTML page was received, React will actually take over,
  // the page (i.e returned pre-rendered page) is hydrated as this process is
  // called (i.e. now hydrate with React code once loaded), which means that now
  // React will turn this into a single page application and take over control
  // and then this useEffect function might be executed, data might be fetched
  // and the page might be updated in the browser, not on the server, not on the
  // pre-rendered page but instead, after this page was received in the browser.
  // And therefore, we then have a fully interactive page (i.e Page / App is interactive)
  // or app with all the data we need!!
  // But if we wanna pre-render a page with data so that this initially returned
  // HTML code already contains the data, we need to fine tune this built-in
  // pre-rendering process and we need to configure it.

  // And for this, NEXTjs gives us two forms of pre-rendering which we can use
  // for controlling how the pages should be rendered.
  // It has something which is called Static Generation.
  // And it has an alternative, which is called Server Side Rendering.
  // Two might sound similar but they run or the code runs at different points
  // of time!!
  // We're going to use the Static Generation approach because that is the
  // approach which we typically should use!

  // How Static Generation works?
  // When using Static Generation, a page component is pre-rendered when we build
  // our application, when we build the NEXT project. So when we build it
  // for production.
  // And that's important. With Static Generation, by default, our page is
  // not pre-rendered on the fly on the server when a request reaches the
  // server. But instead, it is pre-rendered when we as a developer build
  // our site for production. And that means that after it was deployed,
  // that pre-rendered page does not change. At least not by default.
  // If we then updated the data, and we know that the pre-rendered page needs
  // to change,  we need to start that build process again and redeploy again.
  // But that might sound worse than it actually is because for a lot of applications,
  // pages don't change all the time. Page content doesn't change all the time.
  // And if it should change frequently, there are alternatives.

  useEffect(() => {
    // send a http request and fetch data
    // so some promise completed above
    // once that's done, we will set the state updating fn with meetups that we
    // fetched
    setLoadedMeetups(DUMMY_MEETUPS);
  }, []);
  */

  return (
    <Fragment>
      <Head>
        <title>React Meetups</title>
        <meta
          name='description'
          content='Browse a huge list of highly active React meetups!'
        />
      </Head>
      <MeetupList meetups={props.meetups} />;
    </Fragment>
  );
}

// @ Static Generation

// By default, NEXTjs prepares our pages. It by default generates our pages
// already statically and it by default does that during the build process.
// But if we need to wait for data, if we need to add data fetching to a
// page component, we can do so by exporting a special function from inside our
// page component file.
// And that's important! This now only works in our page component files,
// not in other component files. Only in component files inside of the
// pages folder.
// In there we can export a functoin, a fn called getStaticProps and it has
// to be called `getStaticProps`. This is a reserved name so to say.
// NEXTjs will look for a function with that name and if it finds it, it executes
// this function during this pre-rendering process.
// So it will then not directly call our component function and use the returned
// JSX snapshot as HTML content but it will, first of all, call `getStaticProps`
// before it calls the component function.
// And getStaticProps has this name because indeed, its job is to prepare
// props for this page i.e for this HomePage component.
// And these props could then contain the data this page (i.e HomePage) needs.
// And that's useful because `getStaticProps` is allowed to be asynchronous.
// We can return a promise there and then, that's the key thing, NEXTjs will
// wait for this promise to resolve which means it waits until our data is
// loaded and then we return the props for this component function i.e for HomePage.
// And with that, we're able to load data before this component function is
// executed so that this component can be rendered with the required data.
// Now, here in getStaticProps, we can also execute any code that would
// normally only run on a sever. We could access a file system here or
// securely connect to a database because any code that we write inside
// getStaticProps function, will never end up on the client side and it will
// never execute on the client side simply because this code is executed
// during the build process, not on the server and especially not on the
// clients (i.e phone,... browsers) of our visitors.
// So the code in getStaticProps will never reach the machines of our visitors.
// It will never execute on their machines.

// Now, here in getStaticProps, we can do whatever we want. For example, fetch
// data from an API or from a database or read data from some files in the file
// system. But then once we're done with whatever we did to get the data we need,
// we need to return an object here in getStaticProps.
// We always need to return an object here.
// Now in this object, we can configure various things but most importantly, we
// typically set a props property here and it has to be named `props`.
// And that then holds another object, which will be the props object we receive
// in our component function (i.e HomePage) there, in that page component function.
// This now receives a props object and the object will be the object we set as props
// here in getStaticProps.
// And here we could have our meetups key in there.
// The structure of this props object is totally up to us, which holds our
// DUMMY_MEETUPS.
// With that, those DUMMY_MEETUPS would be loaded and prepared in getStaticProps
// and then they would be set as props for this page component i.e HomePage.
// Therefore, in this page component, we no longer need to manage state.
// We no longer need useEffect and we can therefore get rid of those imports
// for useState and useEffect there.
// Because now we get the data through props.
// And our meetups for the MeetupList component are `props.meetups` (in return i.e <MeetupList .. />)
// because we're adding a meetups prop down there.
// And that's how we can move the data fetching away from the client to the
// server side or to be precise to the during the build process side.
// If we now reload our NEXT app, we still see everything but if we now view
// the page source, we see that we no longer have an empty unordered list,
// instead we have an unordered list which has list items with the images and
// title and so on.
// So now this is pre-rendered and it contains the full HTML code and that's
// of course, also great for Search Engines then because now, data is not fetched
// in a second component render cycle on the client but initially, before this
// page is pre-rendered during the build process.
// And that's a great plus and one of the main features of NEXTjs, this data
// fetching for pre-rendering!

// For every data change, we need to start build process again.
// So If data changes frequently, we can add this extra property to the object
// returned by getStaticProps called `revalidate`.
// Using that, we unlock a feature called Incremental Static Generation (ISR).
// `revalidate` wants a number, example 10 and this number is the number of
// seconds NEXTjs will wait until it regenerates this page for an incoming request!
// That means that with revalidate set to some number, this page will not just
// be generated using build process, it will be generated there but not just
// but it will also be generated every couple of seconds on the server, at least
// if there are requests for this page.
// So that means, this page, with revalidate set to 10, would be regenerated
// on the server at least every 10 seconds if there are requests coming in
// for this page.
// And then these re-gnereated pages would replace the old pre-generated pages!
// WIth this we ensure that our data is never older than 10 seconds.
// And therefore the number of seconds we wanna use here depends upon our data
// update frequency.
// If our data changes once every hour, then setting this to 3600 might be great.
// If it changes all the time, one second might be better.

export async function getStaticProps() {
  // Now we're prerendering this page with data that's actually coming from a
  // database.
  // And all this code below will execute whenever this page is pre-generated.
  // So not for every incoming request, because its not `getServerSideProps`
  // but `getStaticProps`.
  // But therefore, during the build process, and when we revalidate, then
  // this page will be pre-rendered and this code below will run again.

  // fetch data from an API
  // NEXTjs adds a feature that we can use fetch() on server side code as well!
  // Normally, we can only use it on the browser but in NEXT projects, we can
  // use fetch() in server side code snippets as well.
  // fetch('/api/meetups');
  const client = await MongoClient.connect(
    'mongodb+srv://colson:startup2025@cluster0.h31egms.mongodb.net/meetups?retryWrites=true&w=majority&appName=Cluster0',
  );
  const db = client.db();

  const meetupsCollection = db.collection('meetups');

  // find() will by default find all the documents in that collection
  // toArray helps us get an array of documents
  const meetups = await meetupsCollection.find().toArray();

  client.close();

  return {
    props: {
      // Error: Error serializing `.meetups[0]._id` returned from `getStaticProps`
      // in "/".
      // Reason: `object` ("[object Object]") cannot be serialized as JSON.
      // Please only return JSON serializable data types.
      meetups: meetups.map((meetup) => ({
        title: meetup.title,
        address: meetup.address,
        image: meetup.image,
        // this will then convert this object to a string which is usable
        id: meetup._id.toString(),
      })),
    },
    revalidate: 1,
  };
}

/* @ Server Side Rendering (SSR) */

// getStaticProps is a very useful fn which we can export in our page components
// to ensure that our pre-rendered pages contain data we might need to wait for.
// Now with `revalidate`, we can ensure that this page is also updated regularly
// after deployment. But sometimes even a regular update is not enough.
// Sometimes we really want to regenerate this page for every incoming request.
// So we want to pre-generate the page dynamically on the fly after deployment
// on the server! Not during the build process and not every couple of seconds
// but for every request.

// If that's our goal, there is an alternative to `getStaticProps`.
// And that would be another function which we can export.
// A function that can also be async if we want to.
// And that's the `getServerSideProps` function.
// Just like getStaticProps, that is a reserved name which NEXTjs would be looking
// for and the difference to getStaticProps is that this fn will now NOT run
// during the build process but instead always on the server after deeployment!!

// Now we'll still return an object here, an object with a props property.
// Because after all, this function still is about getting the props for this
// page component.
// And we can still then fetch data from an API here or from the file system,
// whatever we want to do.
// Any code we write in here will always run on the server, never in he client!
// So we can run server side code here. We can also perform operations that use
// credentials that should not be exposed to our users because this code only
// runs on the server. And then, ultimately, we return our props object.
// So here an object with a `meetups` key which holds our dummy meetups.
// Now we CAN'T set revalidate here because it doesn't make any sense here.
// This `getServerSideProps` function runs for every incoming requests anyways
// so there is no need to revalidate every x seconds.
// Now what we can do in here is we can work with a parameter which we'll receive
// called `context`. We also actually get this in getStaticProps too.
// So we do get it here in getServerSideProps as well.
// And there in this context argument, in this context parameter. We also get
// access to the request object under direct key and the response object that
// will be sent back.
// Having access to the concrete `request` object can be helpful. For example,
// when we're working with authentication, and we need to check some session
// cookie or anything like this.
// So we do have access to the incoming request and all its headers and the
// request body if we need to. And then that might give us extra data or information
// which we need for the code that executes in `getServerSideProps`!
// Ultimately, we then don't return a response by workign on that response
// object here, but instead, we return this object with the props key, which
// holds the props for this page component function..
// So that is how we can then use getServerSideProps for preparing that data
// for our page.
// And if we do use `getServerSideProps` here, if we save everything and reload
// the starting page, we see it works just as before like with getStaticProps.
// BUT NOW, the page is really pre-generated for every incoming request!!

/* export async function getServerSideProps(context) {
  const req = context.req;
  const res = context.res;

  // Fetch data from an API

  return {
    props: {
      meetups: DUMMY_MEETUPS,
    },
  };
} */

/* @ getStaticProps vs getServerSideProps */
// getServerSideProps might sound better because it's guaranteed to run for every
// request. But that actually can be disadvantage, because that means that we need
// to wait for our page to be generated on every incoming request.
// Now if we don't have data that changes all the time and it changes multiple times
// every second, and if we don't need to access to the request object, let's say
// for authentication, `getStaticProps` is actually better.
// Because there we pre-generate an HTML file, that file can then be stored and
// served by a CDN. And that simply is faster than regenerating and fetching that
// data for every incoming request.
// So our page will be faster when working with `getStaticProps` because then
// it can be cached and reused, instead of regenerated all the time.
// Hence, we should really only use `getServerSideProps` if we need access to
// that concrete request object, because we don't have access to request
// and response in `getStaticProps`. Or if we really have data that changes
// multiple times every second and then therefore, even revalidate won't help us
// then `getServerSideProps` is a great choice!

export default HomePage;
